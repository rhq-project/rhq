
<project name="db-upgrade" default="upgrade" basedir=".">

<!--
This target upgrades a database schema.  The parameters that it accepts are:
  jdbc.url              = the jdbc url of the database to upgrade
  jdbc.user             = the user to connect to the database as
  jdbc.password         = the database user's password
  target.schema.version = the schema version to upgrade to. If this is omitted
                          then the schema is upgraded to the latest version.

This target assumes that the taskdefs for the dbupgrade ant task have already been defined.
-->

<target name="upgrade">

<echo>
DB Upgrade:
   JDBC URL: ${jdbc.url}
   JDBC User: ${jdbc.user}
   Update Version: ${target.schema.version}
</echo>

<dbupgrade
   jdbcUrl="${jdbc.url}"
   jdbcUser="${jdbc.user}"
   jdbcPassword="${jdbc.password}"
   valueColumn="PROPERTY_VALUE"
   table="RHQ_SYSTEM_CONFIG"
   keyColumn="PROPERTY_KEY"
   keyMatch="DB_SCHEMA_VERSION"
   targetSchemaVersion="${target.schema.version}">

    <schemaSpec version="2.0">
        <!-- Empty initial schema to avoid install failure on default latest schema version -->
    </schemaSpec>

    <schemaSpec version="2.1">
        <!-- Keep the columnType VARCHAR2, but increase size;
            (see note for RHQ_ALERT_CONDITION table in alert-schema.xml for more info) -->
        <schema-alterColumn
            table="RHQ_ALERT_CONDITION"
            column="OPTION_STATUS"
            columnType="VARCHAR2"
            precision="256" />
    </schemaSpec>

    <schemaSpec version="2.2">
        <!-- RHQ-481 make resource names longer -->
        <schema-alterColumn
            table="RHQ_RESOURCE"
            column="NAME"
            columnType="VARCHAR2"
            precision="500" />
    </schemaSpec>

    <schemaSpec version="2.3">
        <!-- RHQ-666 - Don't require resource name at creation time -->
        <schema-alterColumn
            table="RHQ_CREATE_RES_HIST"
            column="CREATED_RESOURCE_NAME"
            columnType="VARCHAR2"
            precision="500" />
    </schemaSpec>

   <!-- RHQ-669 - Add metadata to package type to indicate architecture support -->
   <schemaSpec version="2.4">
        <schema-addColumn
            table="RHQ_PACKAGE_TYPE"
            column="SUPPORTS_ARCHITECTURE"
            columnType="BOOLEAN" />

        <schema-directSQL>
            <statement targetDBVendor="postgresql"
                       desc="Updating existing package types with default for SUPPORTS_ARCHITECTURE flag">
                UPDATE RHQ_PACKAGE_TYPE SET SUPPORTS_ARCHITECTURE = FALSE
            </statement>
            <statement targetDBVendor="oracle"
                       desc="Updating existing package types with default for SUPPORTS_ARCHITECTURE flag">
                UPDATE RHQ_PACKAGE_TYPE SET SUPPORTS_ARCHITECTURE = 0
            </statement>
        </schema-directSQL>

        <schema-alterColumn
           table="RHQ_PACKAGE_TYPE"
           column="SUPPORTS_ARCHITECTURE"
           nullable="FALSE" />

   </schemaSpec>

   <!-- RHQ-176 - Add notes column to content requests -->
   <schemaSpec version="2.5">
        <schema-addColumn
            table="RHQ_CONTENT_REQ"
            column="NOTES"
            columnType="VARCHAR2"
            precision="512" />
   </schemaSpec>

   <!-- rhq-488 - RHQ High Availability / Failover Support -->
   <schemaSpec version="2.6">

        <!-- RHQ_AFFINITY_GROUP -->
        <schema-directSQL>
             <statement desc="Creating table RHQ_AFFINITY_GROUP">
                  CREATE TABLE RHQ_AFFINITY_GROUP ( ID INTEGER )
             </statement>
        </schema-directSQL>
        <schema-alterColumn table="RHQ_AFFINITY_GROUP" column="ID" nullable="FALSE" />
        <schema-createSequence name="RHQ_AFFINITY_GROUP_ID_SEQ" initial="10001"/>
        <schema-directSQL>
            <statement desc="Creating primary key for RHQ_AFFINITY_GROUP">
                ALTER TABLE RHQ_AFFINITY_GROUP ADD PRIMARY KEY ( ID )
            </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_AFFINITY_GROUP" column="NAME" columnType="VARCHAR2" precision="255"/>
        <schema-alterColumn table="RHQ_AFFINITY_GROUP" column="NAME" nullable="FALSE"/>

        <!-- RHQ_SERVER -->
        <schema-directSQL>
             <statement desc="Creating table RHQ_SERVER">
                  CREATE TABLE RHQ_SERVER ( ID INTEGER )
             </statement>
        </schema-directSQL>
        <schema-alterColumn table="RHQ_SERVER" column="ID" nullable="FALSE" />
        <schema-createSequence name="RHQ_SERVER_ID_SEQ" initial="10001"/>
        <schema-directSQL>
            <statement desc="Creating primary key for RHQ_SERVER">
                ALTER TABLE RHQ_SERVER ADD PRIMARY KEY ( ID )
            </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_SERVER" column="NAME" columnType="VARCHAR2" precision="255"/>
        <schema-alterColumn table="RHQ_SERVER" column="NAME" nullable="FALSE"/>
        <schema-addColumn   table="RHQ_SERVER" column="ADDRESS" columnType="VARCHAR2" precision="255"/>
        <schema-alterColumn table="RHQ_SERVER" column="ADDRESS" nullable="FALSE"/>
        <schema-addColumn   table="RHQ_SERVER" column="PORT" columnType="INTEGER" />
        <schema-alterColumn table="RHQ_SERVER" column="PORT" nullable="FALSE"/>
        <schema-addColumn   table="RHQ_SERVER" column="SECURE_PORT" columnType="INTEGER" />
        <schema-alterColumn table="RHQ_SERVER" column="SECURE_PORT" nullable="FALSE"/>
        <schema-addColumn   table="RHQ_SERVER" column="CTIME" columnType="LONG" />
        <schema-alterColumn table="RHQ_SERVER" column="CTIME" nullable="FALSE"/>
        <schema-addColumn   table="RHQ_SERVER" column="AFFINITY_GROUP_ID" columnType="INTEGER" />
        <schema-directSQL>
             <statement desc="Creating RHQ_SERVER foreign key relation to RHQ_AFFINITY_GROUP">
                  ALTER TABLE RHQ_SERVER
                  ADD CONSTRAINT RHQ_SERVER_AG_ID_FK
                  FOREIGN KEY (AFFINITY_GROUP_ID)
                  REFERENCES RHQ_AFFINITY_GROUP (ID)
             </statement>
        </schema-directSQL>

        <!-- RHQ_AGENT modifications -->
          <schema-addColumn   table="RHQ_AGENT" column="AFFINITY_GROUP_ID" columnType="INTEGER" />
        <schema-directSQL>
             <statement desc="Creating RHQ_AGENT foreign key relation to RHQ_AFFINITY_GROUP">
                  ALTER TABLE RHQ_AGENT
                  ADD CONSTRAINT RHQ_AGENT_AG_ID_FK
                  FOREIGN KEY (AFFINITY_GROUP_ID)
                  REFERENCES RHQ_AFFINITY_GROUP (ID)
             </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_AGENT" column="SERVER_ID" columnType="INTEGER" />
        <schema-directSQL>
             <statement desc="Creating RHQ_AGENT foreign key relation to RHQ_SERVER">
                  ALTER TABLE RHQ_AGENT
                  ADD CONSTRAINT RHQ_AGENT_SERVER_ID_FK
                  FOREIGN KEY (SERVER_ID)
                  REFERENCES RHQ_SERVER (ID)
             </statement>
        </schema-directSQL>

        <!-- RHQ_PARTITION_EVENT -->
        <schema-directSQL>
             <statement desc="Creating table RHQ_PARTITION_EVENT">
                  CREATE TABLE RHQ_PARTITION_EVENT ( ID INTEGER )
             </statement>
        </schema-directSQL>
        <schema-alterColumn table="RHQ_PARTITION_EVENT" column="ID" nullable="FALSE" />
        <schema-createSequence name="RHQ_PARTITION_EVENT_ID_SEQ" initial="10001"/>
        <schema-directSQL>
            <statement desc="Creating primary key for RHQ_PARTITION_EVENT">
                ALTER TABLE RHQ_PARTITION_EVENT ADD PRIMARY KEY ( ID )
            </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_PARTITION_EVENT" column="SUBJECT_NAME" columnType="VARCHAR2" precision="255"/>
        <schema-alterColumn table="RHQ_PARTITION_EVENT" column="SUBJECT_NAME" nullable="FALSE"/>
        <schema-addColumn   table="RHQ_PARTITION_EVENT" column="EVENT_TYPE" columnType="VARCHAR2" precision="50"/>
        <schema-alterColumn table="RHQ_PARTITION_EVENT" column="EVENT_TYPE" nullable="FALSE"/>
        <schema-addColumn   table="RHQ_PARTITION_EVENT" column="CTIME" columnType="LONG" />
        <schema-alterColumn table="RHQ_PARTITION_EVENT" column="CTIME" nullable="FALSE"/>

        <!-- RHQ_PARTITION_DETAILS -->
        <schema-directSQL>
             <statement desc="Creating table RHQ_PARTITION_DETAILS">
                  CREATE TABLE RHQ_PARTITION_DETAILS ( ID INTEGER )
             </statement>
        </schema-directSQL>
        <schema-alterColumn table="RHQ_PARTITION_DETAILS" column="ID" nullable="FALSE" />
        <schema-createSequence name="RHQ_PARTITION_DETAILS_ID_SEQ" initial="10001"/>
        <schema-directSQL>
            <statement desc="Creating primary key for RHQ_PARTITION_DETAILS">
                ALTER TABLE RHQ_PARTITION_DETAILS ADD PRIMARY KEY ( ID )
            </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_PARTITION_DETAILS" column="PARTITION_EVENT_ID" columnType="INTEGER" />
        <schema-alterColumn table="RHQ_PARTITION_DETAILS" column="PARTITION_EVENT_ID" nullable="FALSE"/>
        <schema-directSQL>
             <statement desc="Creating RHQ_PARTITION_DETAILS foreign key relation to RHQ_PARTITION_EVENT">
                  ALTER TABLE RHQ_PARTITION_DETAILS
                  ADD CONSTRAINT RHQ_PD_EVENT_ID_FK
                  FOREIGN KEY (PARTITION_EVENT_ID)
                  REFERENCES RHQ_PARTITION_EVENT (ID)
             </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_PARTITION_DETAILS" column="AGENT_ID" columnType="INTEGER" />
        <schema-alterColumn table="RHQ_PARTITION_DETAILS" column="AGENT_ID" nullable="FALSE"/>
        <schema-directSQL>
             <statement desc="Creating RHQ_PARTITION_DETAILS foreign key relation to RHQ_AGENT">
                  ALTER TABLE RHQ_PARTITION_DETAILS
                  ADD CONSTRAINT RHQ_PD_AGENT_ID_FK
                  FOREIGN KEY (AGENT_ID)
                  REFERENCES RHQ_AGENT (ID)
             </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_PARTITION_DETAILS" column="SERVER_ID" columnType="INTEGER" />
        <schema-alterColumn table="RHQ_PARTITION_DETAILS" column="SERVER_ID" nullable="FALSE"/>
        <schema-directSQL>
             <statement desc="Creating RHQ_PARTITION_DETAILS foreign key relation to RHQ_SERVER">
                  ALTER TABLE RHQ_PARTITION_DETAILS
                  ADD CONSTRAINT RHQ_PD_SERVER_ID_FK
                  FOREIGN KEY (SERVER_ID)
                  REFERENCES RHQ_SERVER (ID)
             </statement>
        </schema-directSQL>

        <!-- RHQ_FAILOVER_LIST -->
        <schema-directSQL>
             <statement desc="Creating table RHQ_FAILOVER_LIST">
                  CREATE TABLE RHQ_FAILOVER_LIST ( ID INTEGER )
             </statement>
        </schema-directSQL>
        <schema-alterColumn table="RHQ_FAILOVER_LIST" column="ID" nullable="FALSE" />
        <schema-createSequence name="RHQ_FAILOVER_LIST_ID_SEQ" initial="10001"/>
        <schema-directSQL>
            <statement desc="Creating primary key for RHQ_FAILOVER_LIST">
                ALTER TABLE RHQ_FAILOVER_LIST ADD PRIMARY KEY ( ID )
            </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_FAILOVER_LIST" column="PARTITION_EVENT_ID" columnType="INTEGER" />
        <schema-alterColumn table="RHQ_FAILOVER_LIST" column="PARTITION_EVENT_ID" nullable="FALSE"/>
        <schema-directSQL>
             <statement desc="Creating RHQ_FAILOVER_LIST foreign key relation to RHQ_PARTITION_EVENT">
                  ALTER TABLE RHQ_FAILOVER_LIST
                  ADD CONSTRAINT RHQ_FL_EVENT_ID_FK
                  FOREIGN KEY (PARTITION_EVENT_ID)
                  REFERENCES RHQ_PARTITION_EVENT (ID)
             </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_FAILOVER_LIST" column="AGENT_ID" columnType="INTEGER" />
        <schema-alterColumn table="RHQ_FAILOVER_LIST" column="AGENT_ID" nullable="FALSE"/>
        <schema-directSQL>
             <statement desc="Creating RHQ_FAILOVER_LIST foreign key relation to RHQ_AGENT">
                  ALTER TABLE RHQ_FAILOVER_LIST
                  ADD CONSTRAINT RHQ_FL_AGENT_ID_FK
                  FOREIGN KEY (AGENT_ID)
                  REFERENCES RHQ_AGENT (ID)
             </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_FAILOVER_LIST" column="CTIME" columnType="LONG" />
        <schema-alterColumn table="RHQ_FAILOVER_LIST" column="CTIME" nullable="FALSE"/>

        <!-- RHQ_FAILOVER_DETAILS -->
        <schema-directSQL>
             <statement desc="Creating table RHQ_FAILOVER_DETAILS">
                  CREATE TABLE RHQ_FAILOVER_DETAILS ( ID INTEGER )
             </statement>
        </schema-directSQL>
        <schema-alterColumn table="RHQ_FAILOVER_DETAILS" column="ID" nullable="FALSE" />
        <schema-createSequence name="RHQ_FAILOVER_DETAILS_ID_SEQ" initial="10001"/>
        <schema-directSQL>
            <statement desc="Creating primary key for RHQ_FAILOVER_DETAILS">
               ALTER TABLE RHQ_FAILOVER_DETAILS ADD PRIMARY KEY ( ID )
            </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_FAILOVER_DETAILS" column="FAILOVER_LIST_ID" columnType="INTEGER" />
        <schema-alterColumn table="RHQ_FAILOVER_DETAILS" column="FAILOVER_LIST_ID" nullable="FALSE"/>
        <schema-directSQL>
             <statement desc="Creating RHQ_FAILOVER_DETAILS foreign key relation to FAILOVER_LIST_ID">
                  ALTER TABLE RHQ_FAILOVER_DETAILS
                  ADD CONSTRAINT RHQ_FD_FAILOVER_LIST_ID_FK
                  FOREIGN KEY (FAILOVER_LIST_ID)
                  REFERENCES RHQ_FAILOVER_LIST (ID)
             </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_FAILOVER_DETAILS" column="SERVER_ID" columnType="INTEGER" />
        <schema-alterColumn table="RHQ_FAILOVER_DETAILS" column="SERVER_ID" nullable="FALSE"/>
        <schema-directSQL>
             <statement desc="Creating RHQ_FAILOVER_DETAILS foreign key relation to RHQ_SERVER">
                  ALTER TABLE RHQ_FAILOVER_DETAILS
                  ADD CONSTRAINT RHQ_FD_SERVER_ID_FK
                  FOREIGN KEY (SERVER_ID)
                  REFERENCES RHQ_SERVER (ID)
             </statement>
        </schema-directSQL>
        <schema-addColumn   table="RHQ_FAILOVER_DETAILS" column="CTIME" columnType="LONG" />
        <schema-alterColumn table="RHQ_FAILOVER_DETAILS" column="CTIME" nullable="FALSE"/>

   </schemaSpec>

   <schemaSpec version="2.7">
        <schema-addColumn   table="RHQ_AGENT" column="STATUS" columnType="INTEGER" />
        <schema-directSQL>
             <statement desc="Updating existing agents with default STATUS flag">
                 UPDATE RHQ_AGENT SET STATUS = 0
             </statement>
        </schema-directSQL>
        <schema-alterColumn table="RHQ_AGENT" column="STATUS" default="0" />
   </schemaSpec>

   <schemaSpec version="2.8">
        <schema-addColumn   table="RHQ_SERVER" column="OPERATION_MODE" columnType="VARCHAR2" precision="32"/>
        <schema-directSQL>
             <statement desc="Updating existing servers with default OPERATION_MODE flag">
                 UPDATE RHQ_SERVER SET OPERATION_MODE = 'NORMAL'
             </statement>
        </schema-directSQL>
        <schema-alterColumn table="RHQ_SERVER" column="OPERATION_MODE" nullable="FALSE"/>

        <schema-directSQL>
            <statement desc="Creating RHQ_SERVER unique constraint on NAME">
                CREATE UNIQUE INDEX rhq_server_name_unique ON rhq_server (name)
            </statement>
        </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.9">
      <schema-addColumn table="RHQ_FAILOVER_DETAILS" column="ORDINAL" columnType="INTEGER" />
   </schemaSpec>

   <schemaSpec version="2.10">
      <schema-deleteColumn table="RHQ_FAILOVER_DETAILS" column="CTIME" />
   </schemaSpec>

   <schemaSpec version="2.11">
      <schema-alterColumn table="RHQ_ALERT_NOTIFICATION" column="ALERT_DEFINITION_ID" nullable="TRUE"/>
   </schemaSpec>

   <schemaSpec version="2.12">
      <schema-deleteColumn table="RHQ_SERVER" column="PORT" />
      <schema-deleteColumn table="RHQ_SERVER" column="SECURE_PORT" />

      <schema-addColumn table="RHQ_SERVER" column="BIND_PORT" columnType="INTEGER"/>
      <schema-directSQL>
         <statement desc="Updating existing servers with default BIND_PORT=7080">
            UPDATE RHQ_SERVER SET BIND_PORT = 7080
         </statement>
      </schema-directSQL>
      <schema-alterColumn table="RHQ_SERVER" column="BIND_PORT" nullable="FALSE"/>

      <schema-addColumn table="RHQ_SERVER" column="TRANSPORT" columnType="VARCHAR2" precision="32"/>
      <schema-directSQL>
         <statement desc="Updating existing servers with default TRANSPORT=servlet">
            UPDATE RHQ_SERVER SET TRANSPORT = 'servlet'
         </statement>
      </schema-directSQL>
      <schema-alterColumn table="RHQ_SERVER" column="TRANSPORT" nullable="FALSE"/>

      <schema-addColumn table="RHQ_SERVER" column="TRANSPORT_PARAMS" columnType="VARCHAR2" precision="512"/>
      <schema-directSQL>
         <statement desc="Updating existing servers with default TRANSPORT_PARAMS=/jboss-remoting-servlet-invoker/ServerInvokerServlet">
            UPDATE RHQ_SERVER SET TRANSPORT_PARAMS = '/jboss-remoting-servlet-invoker/ServerInvokerServlet'
         </statement>
      </schema-directSQL>
      <schema-alterColumn table="RHQ_SERVER" column="TRANSPORT_PARAMS" nullable="FALSE"/>

      <schema-addColumn table="RHQ_SERVER" column="COMPUTE_POWER" columnType="INTEGER"/>
      <schema-directSQL>
         <statement desc="Updating existing servers with default COMPUTE_POWER=1">
            UPDATE RHQ_SERVER SET COMPUTE_POWER = 1
         </statement>
      </schema-directSQL>
      <schema-alterColumn table="RHQ_SERVER" column="COMPUTE_POWER" nullable="FALSE"/>

   </schemaSpec>

   <schemaSpec version="2.13">
      <schema-deleteColumn table="RHQ_SERVER" column="BIND_PORT" />
      <schema-deleteColumn table="RHQ_SERVER" column="TRANSPORT" />
      <schema-deleteColumn table="RHQ_SERVER" column="TRANSPORT_PARAMS" />

      <schema-addColumn table="RHQ_SERVER" column="PORT" columnType="INTEGER"/>
      <schema-directSQL>
         <statement desc="Updating existing servers with default PORT=7080">
            UPDATE RHQ_SERVER SET PORT = 7080
         </statement>
      </schema-directSQL>
      <schema-alterColumn table="RHQ_SERVER" column="PORT" nullable="FALSE"/>
      <schema-addColumn table="RHQ_SERVER" column="SECURE_PORT" columnType="INTEGER"/>
      <schema-directSQL>
         <statement desc="Updating existing servers with default SECURE_PORT=7443">
            UPDATE RHQ_SERVER SET SECURE_PORT = 7443
         </statement>
      </schema-directSQL>
      <schema-alterColumn table="RHQ_SERVER" column="SECURE_PORT" nullable="FALSE"/>
   </schemaSpec>

   <!-- RHQ-720 - Add read_only column to alert definitions table -->
   <schemaSpec version="2.14">
        <schema-addColumn
            table="RHQ_ALERT_DEFINITION"
            column="READ_ONLY"
            columnType="BOOLEAN" />

      <schema-directSQL>
          <statement targetDBVendor="postgresql"
                     desc="Updating existing alert definitions with default for READ_ONLY flag">
              UPDATE RHQ_ALERT_DEFINITION SET READ_ONLY = FALSE
          </statement>
          <statement targetDBVendor="oracle"
            desc="Updating existing alert definitions with default for READ_ONLY flag">
              UPDATE RHQ_ALERT_DEFINITION SET READ_ONLY = 0
          </statement>
      </schema-directSQL>

      <schema-directSQL>
          <statement targetDBVendor="postgresql"
                     desc="Setting alert definition READ_ONLY DEFAULT">
              ALTER TABLE RHQ_ALERT_DEFINITION ALTER COLUMN READ_ONLY SET DEFAULT FALSE
          </statement>
          <statement targetDBVendor="oracle"
                     desc="Setting alert definition READ_ONLY DEFAULT">
             ALTER TABLE RHQ_ALERT_DEFINITION MODIFY READ_ONLY DEFAULT 0
          </statement>
      </schema-directSQL>

      <schema-alterColumn table="RHQ_ALERT_DEFINITION" column="READ_ONLY" nullable="FALSE" />
   </schemaSpec>

   <schemaSpec version="2.15">
      <schema-addColumn table="RHQ_PARTITION_EVENT" column="EXECUTION_STATUS" columnType="VARCHAR2" precision="32"/>
      <schema-directSQL>
         <statement desc="Updating existing partition events with default EXECUTION_STATUS=COMPLETED">
            UPDATE RHQ_PARTITION_EVENT SET EXECUTION_STATUS = 'COMPLETED'
         </statement>
      </schema-directSQL>
      <schema-alterColumn table="RHQ_PARTITION_EVENT" column="EXECUTION_STATUS" nullable="FALSE"/>
   </schemaSpec>

   <schemaSpec version="2.16">
      <schema-addColumn table="RHQ_PARTITION_DETAILS" column="AGENT_NAME" columnType="VARCHAR2" precision="255"/>
      <schema-addColumn table="RHQ_PARTITION_DETAILS" column="SERVER_NAME" columnType="VARCHAR2" precision="255"/>

      <schema-directSQL>
         <statement desc="Updating existing partition events details with default AGENT_NAME">
            UPDATE RHQ_PARTITION_DETAILS SET AGENT_NAME = 'UNKNOWN'
         </statement>
      </schema-directSQL>
      <schema-directSQL>
         <statement desc="Updating existing partition events details with known agents">
            UPDATE RHQ_PARTITION_DETAILS
            SET AGENT_NAME = ( SELECT RHQ_AGENT.NAME
                               FROM RHQ_AGENT
                               WHERE RHQ_AGENT.ID = RHQ_PARTITION_DETAILS.AGENT_ID )
         </statement>
      </schema-directSQL>

      <schema-directSQL>
         <statement desc="Updating existing partition events details with default SERVER_NAME">
            UPDATE RHQ_PARTITION_DETAILS SET SERVER_NAME = 'UNKNOWN'
         </statement>
      </schema-directSQL>
      <schema-directSQL>
         <statement desc="Updating existing partition events details with known servers">
            UPDATE RHQ_PARTITION_DETAILS
            SET SERVER_NAME = ( SELECT RHQ_SERVER.NAME
                                FROM RHQ_SERVER
                                WHERE RHQ_SERVER.ID = RHQ_PARTITION_DETAILS.SERVER_ID )
         </statement>
      </schema-directSQL>

      <schema-deleteColumn table="RHQ_PARTITION_DETAILS" column="AGENT_ID" />
      <schema-deleteColumn table="RHQ_PARTITION_DETAILS" column="SERVER_ID" />
   </schemaSpec>

   <!-- RHQ-786 - Add read_only column to alert definitions table -->
   <schemaSpec version="2.17">
      <schema-addColumn table="RHQ_ALERT" column="RECOVERY_ID" columnType="INTEGER" />

      <schema-directSQL>
          <statement desc="Updating existing alerts with default for recovery_id">
              UPDATE RHQ_ALERT SET RECOVERY_ID = 0
          </statement>
      </schema-directSQL>

      <schema-alterColumn table="RHQ_ALERT" column="RECOVERY_ID" nullable="FALSE" />

      <schema-addColumn table="RHQ_ALERT" column="WILL_RECOVER" columnType="BOOLEAN" />

      <schema-directSQL>
          <statement targetDBVendor="postgresql"
                     desc="Updating existing alerts with default for WILL_RECOVER flag">
              UPDATE RHQ_ALERT SET WILL_RECOVER = FALSE
          </statement>
          <statement targetDBVendor="oracle"
            desc="Updating existing alerts with default for WILL_RECOVER flag">
              UPDATE RHQ_ALERT SET WILL_RECOVER = 0
          </statement>
      </schema-directSQL>

      <schema-directSQL>
          <statement targetDBVendor="postgresql"
                     desc="Setting alert WILL_RECOVER DEFAULT">
              ALTER TABLE RHQ_ALERT ALTER COLUMN WILL_RECOVER SET DEFAULT FALSE
          </statement>
          <statement targetDBVendor="oracle"
                     desc="Setting alert WILL_RECOVER DEFAULT">
            ALTER TABLE RHQ_ALERT MODIFY WILL_RECOVER DEFAULT 0
          </statement>
      </schema-directSQL>

      <schema-alterColumn table="RHQ_ALERT" column="WILL_RECOVER" nullable="FALSE" />
   </schemaSpec>

   <schemaSpec version="2.18">
      <schema-addColumn table="RHQ_PARTITION_EVENT" column="EVENT_DETAIL" columnType="VARCHAR2" precision="512"/>

      <schema-addColumn table="RHQ_SERVER" column="MTIME" columnType="LONG"/>
      <schema-directSQL>
         <statement desc="Updating existing servers with default MTIME=CTIME">
            UPDATE RHQ_SERVER SET MTIME = CTIME
         </statement>
      </schema-directSQL>
      <schema-alterColumn table="RHQ_SERVER" column="MTIME" nullable="FALSE"/>
   </schemaSpec>

   <schemaSpec version="2.19">
      <schema-addColumn table="RHQ_AGENT" column="LAST_AVAILABILITY_REPORT_LONG" columnType="LONG" />
      <schema-directSQL>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_AGENT.LAST_AVAILABILITY_REPORT timestamp to long">
            UPDATE RHQ_AGENT
            SET LAST_AVAILABILITY_REPORT_LONG = EXTRACT ( EPOCH FROM LAST_AVAILABILITY_REPORT )
            WHERE LAST_AVAILABILITY_REPORT IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_AGENT.LAST_AVAILABILITY_REPORT timestamp to long">
            UPDATE RHQ_AGENT
            SET LAST_AVAILABILITY_REPORT_LONG = 1000 *
            (   extract(day    from (LAST_AVAILABILITY_REPORT at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (LAST_AVAILABILITY_REPORT at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (LAST_AVAILABILITY_REPORT at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (LAST_AVAILABILITY_REPORT at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE LAST_AVAILABILITY_REPORT IS NOT NULL
         </statement>
      </schema-directSQL>
      <schema-deleteColumn table="RHQ_AGENT" column="LAST_AVAILABILITY_REPORT" />
      <schema-directSQL>
         <statement desc="Renaming new RHQ_AGENT.LAST_AVAILABILITY_REPORT column to match old schema expectations">
            ALTER TABLE RHQ_AGENT
            RENAME COLUMN LAST_AVAILABILITY_REPORT_LONG
            TO LAST_AVAILABILITY_REPORT
         </statement>
      </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.20">
      <schema-addColumn table="RHQ_ALERT_DAMPEN_EVENT" column="EVENT_TIMESTAMP_LONG" columnType="LONG" />
      <schema-directSQL>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_ALERT_DAMPEN_EVENT.EVENT_TIMESTAMP timestamp to long">
            UPDATE RHQ_ALERT_DAMPEN_EVENT
            SET EVENT_TIMESTAMP_LONG = EXTRACT ( EPOCH FROM EVENT_TIMESTAMP )
            WHERE EVENT_TIMESTAMP IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_ALERT_DAMPEN_EVENT.EVENT_TIMESTAMP timestamp to long">
            UPDATE RHQ_ALERT_DAMPEN_EVENT
            SET EVENT_TIMESTAMP_LONG = 1000 *
            (   extract(day    from (EVENT_TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (EVENT_TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (EVENT_TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (EVENT_TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE EVENT_TIMESTAMP IS NOT NULL
         </statement>
      </schema-directSQL>
      <schema-deleteColumn table="RHQ_ALERT_DAMPEN_EVENT" column="EVENT_TIMESTAMP" />
      <schema-directSQL>
         <statement desc="Renaming new RHQ_ALERT_DAMPEN_EVENT.EVENT_TIMESTAMP column to match old schema expectations">
            ALTER TABLE RHQ_ALERT_DAMPEN_EVENT
            RENAME COLUMN EVENT_TIMESTAMP_LONG
            TO EVENT_TIMESTAMP
         </statement>
      </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.21">
      <schema-addColumn table="RHQ_EVENT" column="TIMESTAMP_LONG" columnType="LONG" />
      <schema-addColumn table="RHQ_EVENT" column="ACK_TIME_LONG" columnType="LONG" />
      <schema-directSQL>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_EVENT.TIMESTAMP timestamp to long">
            UPDATE RHQ_EVENT
            SET TIMESTAMP_LONG = EXTRACT ( EPOCH FROM TIMESTAMP )
            WHERE TIMESTAMP IS NOT NULL
         </statement>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_EVENT.ACK_TIME timestamp to long">
            UPDATE RHQ_EVENT
            SET ACK_TIME_LONG = EXTRACT ( EPOCH FROM ACK_TIME )
            WHERE ACK_TIME IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_EVENT.TIMESTAMP timestamp to long">
            UPDATE RHQ_EVENT
            SET TIMESTAMP_LONG = 1000 *
            (   extract(day    from (TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE TIMESTAMP IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_EVENT.ACK_TIME timestamp to long">
            UPDATE RHQ_EVENT
            SET ACK_TIME_LONG = 1000 *
            (   extract(day    from (ACK_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (ACK_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (ACK_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (ACK_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE ACK_TIME IS NOT NULL
         </statement>
      </schema-directSQL>
      <schema-deleteColumn table="RHQ_EVENT" column="TIMESTAMP" />
      <schema-deleteColumn table="RHQ_EVENT" column="ACK_TIME" />
      <schema-directSQL>
         <statement desc="Renaming new RHQ_EVENT.TIMESTAMP column to match old schema expectations">
            ALTER TABLE RHQ_EVENT
            RENAME COLUMN TIMESTAMP_LONG
            TO TIMESTAMP
         </statement>
         <statement desc="Renaming new RHQ_EVENT.ACK_TIME column to match old schema expectations">
            ALTER TABLE RHQ_EVENT
            RENAME COLUMN ACK_TIME_LONG
            TO ACK_TIME
         </statement>
      </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.22">
      <!-- RHQ_CONTENT_SOURCE timestamp to long conversion -->
      <schema-addColumn table="RHQ_CONTENT_SOURCE" column="CREATION_TIME_LONG" columnType="LONG" />
      <schema-addColumn table="RHQ_CONTENT_SOURCE" column="LAST_MODIFIED_TIME_LONG" columnType="LONG" />
      <schema-directSQL>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_CONTENT_SOURCE.CREATION_TIME timestamp to long">
            UPDATE RHQ_CONTENT_SOURCE
            SET CREATION_TIME_LONG = EXTRACT ( EPOCH FROM CREATION_TIME )
            WHERE CREATION_TIME IS NOT NULL
         </statement>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_CONTENT_SOURCE.LAST_MODIFIED_TIME timestamp to long">
            UPDATE RHQ_CONTENT_SOURCE
            SET LAST_MODIFIED_TIME_LONG = EXTRACT ( EPOCH FROM LAST_MODIFIED_TIME )
            WHERE LAST_MODIFIED_TIME IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_CONTENT_SOURCE.CREATION_TIME timestamp to long">
            UPDATE RHQ_CONTENT_SOURCE
            SET CREATION_TIME_LONG = 1000 *
            (   extract(day    from (CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE CREATION_TIME IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_CONTENT_SOURCE.LAST_MODIFIED_TIME timestamp to long">
            UPDATE RHQ_CONTENT_SOURCE
            SET LAST_MODIFIED_TIME_LONG = 1000 *
            (   extract(day    from (LAST_MODIFIED_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (LAST_MODIFIED_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (LAST_MODIFIED_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (LAST_MODIFIED_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE LAST_MODIFIED_TIME IS NOT NULL
         </statement>
      </schema-directSQL>
      <schema-deleteColumn table="RHQ_CONTENT_SOURCE" column="CREATION_TIME" />
      <schema-deleteColumn table="RHQ_CONTENT_SOURCE" column="LAST_MODIFIED_TIME" />
      <schema-directSQL>
         <statement desc="Renaming new RHQ_CONTENT_SOURCE.CREATION_TIME column to match old schema expectations">
            ALTER TABLE RHQ_CONTENT_SOURCE
            RENAME COLUMN CREATION_TIME_LONG
            TO CREATION_TIME
         </statement>
         <statement desc="Renaming new RHQ_CONTENT_SOURCE.LAST_MODIFIED_TIME column to match old schema expectations">
            ALTER TABLE RHQ_CONTENT_SOURCE
            RENAME COLUMN LAST_MODIFIED_TIME_LONG
            TO LAST_MODIFIED_TIME
         </statement>
      </schema-directSQL>

      <!-- RHQ_CHANNEL timestamp to long conversion -->
      <schema-addColumn table="RHQ_CHANNEL" column="CREATION_TIME_LONG" columnType="LONG" />
      <schema-addColumn table="RHQ_CHANNEL" column="LAST_MODIFIED_TIME_LONG" columnType="LONG" />
      <schema-directSQL>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_CHANNEL.CREATION_TIME timestamp to long">
            UPDATE RHQ_CHANNEL
            SET CREATION_TIME_LONG = EXTRACT ( EPOCH FROM CREATION_TIME )
            WHERE CREATION_TIME IS NOT NULL
         </statement>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_CHANNEL.LAST_MODIFIED_TIME timestamp to long">
            UPDATE RHQ_CHANNEL
            SET LAST_MODIFIED_TIME_LONG = EXTRACT ( EPOCH FROM LAST_MODIFIED_TIME )
            WHERE LAST_MODIFIED_TIME IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_CHANNEL.CREATION_TIME timestamp to long">
            UPDATE RHQ_CHANNEL
            SET CREATION_TIME_LONG = 1000 *
            (   extract(day    from (CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE CREATION_TIME IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_CHANNEL.LAST_MODIFIED_TIME timestamp to long">
            UPDATE RHQ_CHANNEL
            SET LAST_MODIFIED_TIME_LONG = 1000 *
            (   extract(day    from (LAST_MODIFIED_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (LAST_MODIFIED_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (LAST_MODIFIED_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (LAST_MODIFIED_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE LAST_MODIFIED_TIME IS NOT NULL
         </statement>
      </schema-directSQL>
      <schema-deleteColumn table="RHQ_CHANNEL" column="CREATION_TIME" />
      <schema-deleteColumn table="RHQ_CHANNEL" column="LAST_MODIFIED_TIME" />
      <schema-directSQL>
         <statement desc="Renaming new RHQ_CHANNEL.CREATION_TIME column to match old schema expectations">
            ALTER TABLE RHQ_CHANNEL
            RENAME COLUMN CREATION_TIME_LONG
            TO CREATION_TIME
         </statement>
         <statement desc="Renaming new RHQ_CHANNEL.LAST_MODIFIED_TIME column to match old schema expectations">
            ALTER TABLE RHQ_CHANNEL
            RENAME COLUMN LAST_MODIFIED_TIME_LONG
            TO LAST_MODIFIED_TIME
         </statement>
      </schema-directSQL>

      <!-- RHQ_PACKAGE_VERSION timestamp to long conversion -->
      <schema-addColumn table="RHQ_PACKAGE_VERSION" column="FILE_CREATION_TIME_LONG" columnType="LONG" />
      <schema-directSQL>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_PACKAGE_VERSION.FILE_CREATION_TIME timestamp to long">
            UPDATE RHQ_PACKAGE_VERSION
            SET FILE_CREATION_TIME_LONG = EXTRACT ( EPOCH FROM FILE_CREATION_TIME )
            WHERE FILE_CREATION_TIME IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_PACKAGE_VERSION.FILE_CREATION_TIME timestamp to long">
            UPDATE RHQ_PACKAGE_VERSION
            SET FILE_CREATION_TIME_LONG = 1000 *
            (   extract(day    from (FILE_CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (FILE_CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (FILE_CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (FILE_CREATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE FILE_CREATION_TIME IS NOT NULL
         </statement>
      </schema-directSQL>
      <schema-deleteColumn table="RHQ_PACKAGE_VERSION" column="FILE_CREATION_TIME" />
      <schema-directSQL>
         <statement desc="Renaming new RHQ_PACKAGE_VERSION.FILE_CREATION_TIME column to match old schema expectations">
            ALTER TABLE RHQ_PACKAGE_VERSION
            RENAME COLUMN FILE_CREATION_TIME_LONG
            TO FILE_CREATION_TIME
         </statement>
      </schema-directSQL>

      <!-- RHQ_INSTALLED_PACKAGE timestamp to long conversion -->
      <schema-addColumn table="RHQ_INSTALLED_PACKAGE" column="INSTALLATION_TIME_LONG" columnType="LONG" />
      <schema-directSQL>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_INSTALLED_PACKAGE.INSTALLATION_TIME timestamp to long">
            UPDATE RHQ_INSTALLED_PACKAGE
            SET INSTALLATION_TIME_LONG = EXTRACT ( EPOCH FROM INSTALLATION_TIME )
            WHERE INSTALLATION_TIME IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_INSTALLED_PACKAGE.INSTALLATION_TIME timestamp to long">
            UPDATE RHQ_INSTALLED_PACKAGE
            SET INSTALLATION_TIME_LONG = 1000 *
            (   extract(day    from (INSTALLATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (INSTALLATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (INSTALLATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (INSTALLATION_TIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE INSTALLATION_TIME IS NOT NULL
         </statement>
      </schema-directSQL>
      <schema-deleteColumn table="RHQ_INSTALLED_PACKAGE" column="INSTALLATION_TIME" />
      <schema-directSQL>
         <statement desc="Renaming new RHQ_INSTALLED_PACKAGE.INSTALLATION_TIME column to match old schema expectations">
            ALTER TABLE RHQ_INSTALLED_PACKAGE
            RENAME COLUMN INSTALLATION_TIME_LONG
            TO INSTALLATION_TIME
         </statement>
      </schema-directSQL>

      <!-- RHQ_INSTALLED_PKG_HIST timestamp to long conversion -->
      <schema-addColumn table="RHQ_INSTALLED_PKG_HIST" column="HISTORY_TIMESTAMP_LONG" columnType="LONG" />
      <schema-directSQL>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_INSTALLED_PKG_HIST.HISTORY_TIMESTAMP timestamp to long">
            UPDATE RHQ_INSTALLED_PKG_HIST
            SET HISTORY_TIMESTAMP_LONG = EXTRACT ( EPOCH FROM HISTORY_TIMESTAMP )
            WHERE HISTORY_TIMESTAMP IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_INSTALLED_PKG_HIST.HISTORY_TIMESTAMP timestamp to long">
            UPDATE RHQ_INSTALLED_PKG_HIST
            SET HISTORY_TIMESTAMP_LONG = 1000 *
            (   extract(day    from (HISTORY_TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (HISTORY_TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (HISTORY_TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (HISTORY_TIMESTAMP at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE HISTORY_TIMESTAMP IS NOT NULL
         </statement>
      </schema-directSQL>
      <schema-deleteColumn table="RHQ_INSTALLED_PKG_HIST" column="HISTORY_TIMESTAMP" />
      <schema-directSQL>
         <statement desc="Renaming new RHQ_INSTALLED_PKG_HIST.HISTORY_TIMESTAMP column to match old schema expectations">
            ALTER TABLE RHQ_INSTALLED_PKG_HIST
            RENAME COLUMN HISTORY_TIMESTAMP_LONG
            TO HISTORY_TIMESTAMP
         </statement>
      </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.23">
      <schema-addColumn table="RHQ_MEASUREMENT_SCHED" column="MTIME_LONG" columnType="LONG" />
      <schema-directSQL>
         <statement targetDBVendor="postgresql"
                    desc="Converting RHQ_MEASUREMENT_SCHED.MTIME timestamp to long">
            UPDATE RHQ_MEASUREMENT_SCHED
            SET MTIME_LONG = EXTRACT ( EPOCH FROM MTIME )
            WHERE MTIME IS NOT NULL
         </statement>
         <statement targetDBVendor="oracle"
                    desc="Converting RHQ_MEASUREMENT_SCHED.MTIME timestamp to long">
            UPDATE RHQ_MEASUREMENT_SCHED
            SET MTIME_LONG = 1000 *
            (   extract(day    from (MTIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*86400+
                extract(hour   from (MTIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*3600+
                extract(minute from (MTIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))*60+
                extract(second from (MTIME at time zone 'UTC' - timestamp '1970-01-01 00:00:00 +00:00'))
            )
            WHERE MTIME IS NOT NULL
         </statement>
      </schema-directSQL>
      <schema-deleteColumn table="RHQ_MEASUREMENT_SCHED" column="MTIME" />
      <schema-directSQL>
         <statement desc="Renaming new RHQ_MEASUREMENT_SCHED.MTIME column to match old schema expectations">
            ALTER TABLE RHQ_MEASUREMENT_SCHED
            RENAME COLUMN MTIME_LONG
            TO MTIME
         </statement>
      </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.24">
      <schema-directSQL>
         <statement desc="Creating RHQ_MEASUREMENT_BLINE index on SCHEDULE_ID">
            CREATE INDEX rhq_meas_baseline_sid_idx ON rhq_measurement_bline (schedule_id)
         </statement>
      </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.25">
      <schema-dropTable table="RHQ_MEASUREMENT_OOB" />
      <schema-dropSequence name="rhq_measurement_oob_id_seq" />
   </schemaSpec>

   <schemaSpec version="2.26">
      <schema-directSQL>
         <statement desc="Unscheduling auto-baseline job from Quartz - removing trigger">
            DELETE FROM rhq_qrtz_triggers WHERE trigger_name='org.rhq.enterprise.server.scheduler.jobs.AutoBaselineCalculationJob'
         </statement>
         <statement desc="Unscheduling auto-baseline job from Quartz - removing simple trigger">
            DELETE FROM rhq_qrtz_simple_triggers WHERE trigger_name='org.rhq.enterprise.server.scheduler.jobs.AutoBaselineCalculationJob'
         </statement>
         <statement desc="Unscheduling auto-baseline job from Quartz - removing job details">
            DELETE FROM rhq_qrtz_job_details WHERE job_name='org.rhq.enterprise.server.scheduler.jobs.AutoBaselineCalculationJob'
         </statement>
      </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.27">
      <schema-directSQL>
         <statement desc="Adding Agent Max Quiet Time Allowed system configuration setting">
            INSERT INTO rhq_system_config (id, property_key, property_value, default_property_value)
                   VALUES (52, 'AGENT_MAX_QUIET_TIME_ALLOWED', '120000', '120000')
         </statement>
      </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.28">
      <schema-directSQL>
         <statement desc="Adding Enable Agent Auto Update system configuration setting">
            INSERT INTO rhq_system_config (id, property_key, property_value, default_property_value)
                   VALUES (53, 'ENABLE_AGENT_AUTO_UPDATE', 'true', 'true')
         </statement>
      </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.29">
      <schema-directSQL>
         <statement desc="Adding Trait Purge system configuration setting">
            INSERT INTO rhq_system_config (id, property_key, property_value, default_property_value)
                   VALUES (54, 'TRAIT_PURGE', '31536000000', '31536000000')
         </statement>
         <statement desc="Adding Avail Purge system configuration setting">
            INSERT INTO rhq_system_config (id, property_key, property_value, default_property_value)
                   VALUES (55, 'AVAILABILITY_PURGE', '31536000000', '31536000000')
         </statement>
      </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.30">
      <!-- RHQ_RESOURCE_AVAIL -->
      <schema-directSQL>
         <statement desc="Creating table RHQ_RESOURCE_AVAIL">
            CREATE TABLE RHQ_RESOURCE_AVAIL ( ID INTEGER )
         </statement>
      </schema-directSQL>
      <schema-alterColumn table="RHQ_RESOURCE_AVAIL" column="ID" nullable="FALSE" />
      <schema-createSequence name="RHQ_RESOURCE_AVAIL_ID_SEQ" initial="10001"/>
      <schema-directSQL>
         <statement desc="Creating primary key for RHQ_RESOURCE_AVAIL">
            ALTER TABLE RHQ_RESOURCE_AVAIL ADD PRIMARY KEY ( ID )
         </statement>
      </schema-directSQL>
      <schema-addColumn   table="RHQ_RESOURCE_AVAIL" column="RESOURCE_ID" columnType="INTEGER" />
      <schema-alterColumn table="RHQ_RESOURCE_AVAIL" column="RESOURCE_ID" nullable="FALSE" />
      <schema-directSQL>
         <statement desc="Creating RHQ_RESOURCE_AVAIL foreign key relation to RHQ_RESOURCE">
            ALTER TABLE RHQ_RESOURCE_AVAIL
            ADD CONSTRAINT RHQ_RES_AVAIL_RES_ID_FK
            FOREIGN KEY ( RESOURCE_ID )
            REFERENCES RHQ_RESOURCE ( ID )
            ON DELETE CASCADE
         </statement>
      </schema-directSQL>
      <schema-addColumn   table="RHQ_RESOURCE_AVAIL" column="AVAILABILITY_TYPE" columnType="SMALLINT" />
      <schema-directSQL>
         <statement targetDBVendor="oracle"
                    desc="Inserting known, current availability data into RHQ_RESOURCE_AVAIL">
            INSERT INTO RHQ_RESOURCE_AVAIL ( ID, RESOURCE_ID, AVAILABILITY_TYPE )
            SELECT RHQ_RESOURCE_AVAIL_ID_SEQ.NEXTVAL, RES.ID, AVAIL.AVAILABILITY_TYPE
            FROM RHQ_RESOURCE RES
            LEFT JOIN RHQ_AVAILABILITY AVAIL ON AVAIL.RESOURCE_ID = RES.ID
            WHERE AVAIL.START_TIME = ( SELECT MAX( A.START_TIME )
                                       FROM RHQ_AVAILABILITY A
                                       WHERE A.RESOURCE_ID = RES.ID )
         </statement>
         <statement targetDBVendor="postgresql"
                    desc="Inserting known, current availability data into RHQ_RESOURCE_AVAIL">
            INSERT INTO RHQ_RESOURCE_AVAIL ( ID, RESOURCE_ID, AVAILABILITY_TYPE )
            SELECT nextval('RHQ_RESOURCE_AVAIL_ID_SEQ'::text), RES.ID, AVAIL.AVAILABILITY_TYPE
            FROM RHQ_RESOURCE RES
            LEFT JOIN RHQ_AVAILABILITY AVAIL ON AVAIL.RESOURCE_ID = RES.ID
            WHERE AVAIL.START_TIME = ( SELECT MAX( A.START_TIME )
                                       FROM RHQ_AVAILABILITY A
                                       WHERE A.RESOURCE_ID = RES.ID )
         </statement>
      </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.31">
      <!-- The following three columns support backing groups for resource clusters -->
      <schema-addColumn
         table="RHQ_RESOURCE_GROUP"
         column="CLUSTER_RESOURCE_GROUP_ID"
         columnType="INTEGER"/>
      <schema-directSQL>
           <statement desc="Creating RHQ_RESOURCE_GROUP foreign key relation to RHQ_RESOURCE_GROUP for resource cluster groups">
                ALTER TABLE RHQ_RESOURCE_GROUP
                ADD CONSTRAINT RHQ_RESOURCE_GROUP_ID_FK
                FOREIGN KEY (CLUSTER_RESOURCE_GROUP_ID)
                REFERENCES RHQ_RESOURCE_GROUP (ID)
           </statement>
      </schema-directSQL>

      <schema-addColumn
         table="RHQ_RESOURCE_GROUP"
         column="CLUSTER_KEY"
         columnType="VARCHAR2"
         precision="4000"/>

      <schema-addColumn
         table="RHQ_RESOURCE_GROUP"
         column="VISIBLE"
         columnType="BOOLEAN" />

      <schema-directSQL>
          <statement targetDBVendor="postgresql"
                     desc="Updating existing resource groups with default for VISIBLE  flag">
              UPDATE RHQ_RESOURCE_GROUP SET VISIBLE = TRUE
          </statement>
          <statement targetDBVendor="oracle"
                     desc="Updating existing resource groups with default for VISIBLE  flag">
              UPDATE RHQ_RESOURCE_GROUP SET VISIBLE = 1
          </statement>
      </schema-directSQL>

      <!-- The following constraint change forces cascade delete of config_update if the parent config is deleted -->
      <schema-directSQL>
         <statement targetDBVendor="postgresql" desc="Dropping RHQ_CONFIG_UPDATE foreign key relation to RHQ_CONFIG">
            ALTER TABLE rhq_config_update DROP CONSTRAINT rhq_config_update_configuration_id_fkey;
         </statement>
         <!-- the following PL/SQL is necessary since we have to deal with generated constraint names in the ora dbs -->
         <statement targetDBVendor="oracle" desc="Dropping RHQ_CONFIG_UPDATE foreign key relation to RHQ_CONFIG">
            DECLARE
               CURSOR c IS
                  SELECT uc.constraint_name con
                  FROM   user_constraints uc, user_cons_columns ucc
                  WHERE  uc.table_name = 'RHQ_CONFIG_UPDATE'AND
                         uc.constraint_type = 'R' AND
                         uc.table_name = ucc.table_name AND
                         uc.constraint_name = ucc.constraint_name AND
                         ucc.column_name = 'CONFIGURATION_ID'
               ;
               alter_string VARCHAR2(500);
            BEGIN
               FOR r IN c LOOP
                  alter_string := 'ALTER TABLE RHQ_CONFIG_UPDATE DROP CONSTRAINT ' || r.con;
                  EXECUTE IMMEDIATE alter_string;
               END LOOP;
            END;
         </statement>
         <statement desc="Creating new RHQ_CONFIG_UPDATE foreign key relation to RHQ_CONFIG">
            ALTER TABLE RHQ_CONFIG_UPDATE
            ADD CONSTRAINT fk_config_update_config_1 FOREIGN KEY (configuration_id)
            REFERENCES rhq_config ( id )
            ON DELETE CASCADE
         </statement>

      </schema-directSQL>

   </schemaSpec>

   <schemaSpec version="2.32">
      <!-- Remove the ClusterManagerJob from the Quartz tables. It has been renamed. Note that deleting the job
           removes other rows by cascade delete. -->
      <schema-directSQL>
         <statement desc="Remove the ClusterManagerJob from the Quartz tables. It has been renamed.">
            DELETE FROM rhq_qrtz_job_details WHERE job_name = 'org.rhq.enterprise.server.scheduler.jobs.ClusterManagerJob'
         </statement>
      </schema-directSQL>

   </schemaSpec>

   <schemaSpec version="2.33">
      <schema-deleteColumn table="RHQ_EVENT" column="ACK_TIME" />
      <schema-deleteColumn table="RHQ_EVENT" column="ACK_USER" />
   </schemaSpec>

   <!-- delete all constant data no longer used -->
   <schemaSpec version="2.34">
      <schema-directSQL>
         <statement desc="Removing configuration data property no longer used">
            DELETE FROM rhq_system_config
            WHERE property_key = 'CAM_DATA_PURGE_RAW'
         </statement>
         <statement desc="Removing configuration data property no longer used">
            DELETE FROM rhq_system_config
            WHERE property_key = 'CAM_MULTICAST_ADDRESS'
         </statement>
         <statement desc="Removing configuration data property no longer used">
            DELETE FROM rhq_system_config
            WHERE property_key = 'CAM_MULTICAST_PORT'
         </statement>
         <statement desc="Removing configuration data property no longer used">
            DELETE FROM rhq_system_config
            WHERE property_key = 'DATA_STORE_ALL'
         </statement>
      </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.35">
      <!-- Remove RHQ_RESOURCE_GROUP.CLUSTER_KEY added in 2.31. This value will instead be the group name -->
      <schema-deleteColumn table="RHQ_RESOURCE_GROUP" column="CLUSTER_KEY" />
      <!-- Increase RHQ_RESOURCE_GROUP.NAME to accomodate the potentially large cluster key values -->
      <schema-alterColumn
          table="RHQ_RESOURCE_GROUP"
          column="NAME"
          columnType="VARCHAR2"
          precision="4000" />
   </schemaSpec>

   <schemaSpec version="2.36">
      <schema-directSQL>
         <statement desc="Deleting unique constraint on RHQ_MEASUREMENT_DEF">
            DROP INDEX RHQ_METRIC_DEF_KEY_IDX
         </statement>
      </schema-directSQL>
      <schema-deleteColumn table="RHQ_MEASUREMENT_DEF" column="PER_MINUTE" />
      <schema-addColumn table="RHQ_MEASUREMENT_DEF" column="RAW_NUMERIC_TYPE" columnType="SMALLINT" />
      <schema-directSQL>
         <statement desc="Populating values for new column RHQ_MEASUREMENT_DEF.RAW_NUMERIC_TYPE">
            UPDATE RHQ_MEASUREMENT_DEF md SET RAW_NUMERIC_TYPE = (SELECT NUMERIC_TYPE FROM RHQ_MEASUREMENT_DEF
            WHERE NAME = md.NAME AND RESOURCE_TYPE_ID = md.RESOURCE_TYPE_ID AND (NUMERIC_TYPE = 1 OR NUMERIC_TYPE = 2))
            WHERE NUMERIC_TYPE = 0
         </statement>
      </schema-directSQL>
      <schema-directSQL>
         <statement desc="Creating unique index on RHQ_MEASUREMENT_DEF (RESOURCE_TYPE_ID, NAME, RAW_NUMERIC_TYPE)">
            CREATE UNIQUE INDEX RHQ_METRIC_DEF_KEY_IDX ON RHQ_MEASUREMENT_DEF (RESOURCE_TYPE_ID, NAME, RAW_NUMERIC_TYPE)
         </statement>
      </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.37">
      <schema-addColumn table="RHQ_GROUP_DEF" column="CALC_INTERVAL" columnType="LONG" />
      <schema-directSQL>
         <statement desc="Defaulting all group definition recalculation intervals">
            UPDATE RHQ_GROUP_DEF SET CALC_INTERVAL = 0
         </statement>
      </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.38">
      <!-- Keep these with the same columnType=VARCHAR2, but increase size -->
      <schema-alterColumn
         table="RHQ_CONTENT_SOURCE"
         column="NAME"
         columnType="VARCHAR2"
         precision="200" />

      <schema-alterColumn
         table="RHQ_CONTENT_SOURCE_TYPE"
         column="NAME"
         columnType="VARCHAR2"
         precision="200" />

      <schema-directSQL>
         <statement desc="Removing obsolete content source sync jobs">
            DELETE FROM RHQ_QRTZ_CRON_TRIGGERS WHERE TRIGGER_GROUP = 'syncContentSource'
         </statement>
         <statement>
            DELETE FROM RHQ_QRTZ_JOB_DETAILS WHERE JOB_GROUP = 'syncContentSource'
         </statement>
         <statement>
            DELETE FROM RHQ_QRTZ_SIMPLE_TRIGGERS WHERE TRIGGER_GROUP = 'syncContentSource'
         </statement>
         <statement>
            DELETE FROM RHQ_QRTZ_TRIGGERS WHERE TRIGGER_GROUP = 'syncContentSource'
         </statement>
         <statement>
            DELETE FROM RHQ_QRTZ_FIRED_TRIGGERS WHERE TRIGGER_GROUP = 'syncContentSource'
         </statement>
      </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.39">
       <!-- add a new table for OOBs -->
       <schema-directSQL>
          <statement desc="Creating table RHQ_MEASUREMENT_OOB">
              CREATE TABLE RHQ_MEASUREMENT_OOB ( SCHEDULE_ID INTEGER )
          </statement>
       </schema-directSQL>
       <schema-alterColumn table="RHQ_MEASUREMENT_OOB" column="SCHEDULE_ID" nullable="FALSE" />
       <schema-addColumn   table="RHQ_MEASUREMENT_OOB" column="TIME_STAMP" columnType="LONG" />
       <schema-alterColumn table="RHQ_MEASUREMENT_OOB" column="TIME_STAMP" nullable="FALSE" />
       <schema-directSQL>
          <statement desc="Creating primary key for RHQ_MEASUREMENT_OOB">
             ALTER TABLE RHQ_MEASUREMENT_OOB ADD PRIMARY KEY ( TIME_STAMP, SCHEDULE_ID )
          </statement>
       </schema-directSQL>
       <schema-directSQL>
          <statement desc="Creating RHQ_MEASUREMENT_OOB foreign key relation to RHQ_MEASUREMENT_SCHED">
             ALTER TABLE RHQ_MEASUREMENT_OOB
             ADD CONSTRAINT RHQ_M_OOB_M_SCHED_ID_FK
             FOREIGN KEY ( SCHEDULE_ID )
             REFERENCES RHQ_MEASUREMENT_SCHED ( ID )
             ON DELETE CASCADE
          </statement>
       </schema-directSQL>

       <schema-addColumn   table="RHQ_MEASUREMENT_OOB" column="OOB_COUNT" columnType="INTEGER" />
       <schema-alterColumn table="RHQ_MEASUREMENT_OOB" column="OOB_COUNT" nullable="FALSE" />
       <schema-addColumn   table="RHQ_MEASUREMENT_OOB" column="OOB_FACTOR" columnType="INTEGER" />
       <schema-alterColumn table="RHQ_MEASUREMENT_OOB" column="OOB_FACTOR" nullable="FALSE" />

   </schemaSpec>

   <schemaSpec version="2.40">
      <schema-directSQL>
         <statement desc="Changing the default event purge time in system configuration to 2 weeks">
            UPDATE RHQ_SYSTEM_CONFIG SET PROPERTY_VALUE = '1209600000' WHERE PROPERTY_KEY = 'EVENT_PURGE'
         </statement>
      </schema-directSQL>
   </schemaSpec>

   <schemaSpec version="2.41">
      <schema-addColumn table="RHQ_PLUGIN" column="CONTENT" columnType="BLOB" />
   </schemaSpec>

    <schemaSpec version="2.42">
       <schema-addColumn table="RHQ_PLUGIN" column="MTIME" columnType="LONG" />
       <schema-directSQL>
          <statement desc="Setting the plugin modified times to the same as created times">
             UPDATE RHQ_PLUGIN SET MTIME = CTIME
          </statement>
       </schema-directSQL>
       <schema-alterColumn table="RHQ_PLUGIN" column="MTIME" nullable="FALSE"/>
    </schemaSpec>

    <schemaSpec version="2.43">
        <schema-deleteColumn table="RHQ_MEASUREMENT_OOB" column="OOB_COUNT"/>
    </schemaSpec>

</dbupgrade>

</target>

</project>
